// Nu Game Engine.
// Copyright (C) Bryan Edds, 2013-2018.

//*********************************************************************************************//
//                                                                                             //
// NOTE: This code is GENERATED by 'GenerateWorldBindings.fsx'! Do NOT edit this code by hand! //
//                                                                                             //
//*********************************************************************************************//

namespace Nu
open System
open OpenTK
open Prime
open global.Nu

[<RequireQualifiedAccess>]
module WorldBindings =

    let [<Literal>] BindingKeywords =
        "v2 v4 v2i get getAsStream set setAsStream update streamEvent stream equate self parent grandparent game toData monitor " +
        "resolve reloadAssets tryGetIsSelectedScreenIdling tryGetIsSelectedScreenTransitioning isSelectedScreenIdling " +
        "isSelectedScreenTransitioning selectScreen tryTransitionScreen transitionScreen " +
        "createDissolveScreenFromLayerFile6 createDissolveScreenFromLayerFile createSplashScreen6 createSplashScreen " +
        "getEntitiesInView2 getEntitiesInBounds3 getEntitiesAtPoint3 getEntitiesInView " +
        "getEntitiesInBounds getEntitiesAtPoint playSong playSong4 " +
        "playSound playSound3 fadeOutSong stopSong " +
        "hintAudioPackageUse hintAudioPackageDisuse reloadAudioAssets hintRenderPackageUse " +
        "hintRenderPackageDisuse reloadRenderAssets bodyExists getBodyContactNormals " +
        "getBodyLinearVelocity getBodyToGroundContactNormals getBodyToGroundContactNormalOpt getBodyToGroundContactTangentOpt " +
        "isBodyOnGround createBody createBodies destroyBody " +
        "destroyBodies setBodyPosition setBodyRotation setBodyAngularVelocity " +
        "setBodyLinearVelocity applyBodyAngularImpulse applyBodyLinearImpulse applyBodyForce " +
        "isMouseButtonDown getMousePosition getMousePositionF isKeyboardKeyDown " +
        "getSelected tryGetParent getParent tryGetGrandparent " +
        "getGrandparent getChildren getExists getEntities0 " +
        "getLayers0 isSimulantSelected writeGameToFile readGameFromFile " +
        "getScreens destroyScreen createScreen createDissolveScreen " +
        "writeScreenToFile readScreenFromFile getLayers destroyLayer " +
        "destroyLayers writeLayerToFile readLayerFromFile getEntities " +
        "destroyEntity destroyEntities tryPickEntity createEntity " +
        "reassignEntity trySetEntityOverlayNameOpt trySetEntityFacetNames createLayer " +
        "getEyeCenter setEyeCenter getEyeSize setEyeSize " +
        "getOmniScreenOpt setOmniScreenOpt getOmniScreen setOmniScreen " +
        "getSelectedScreenOpt setSelectedScreenOpt getSelectedScreen setSelectedScreen " +
        "getScreenTransitionDestinationOpt getViewBoundsRelative getViewBoundsAbsolute getViewBounds " +
        "isBoundsInView mouseToScreen mouseToWorld mouseToEntity " +
        "getTickRate getTickRateF setTickRate resetTickTime " +
        "incTickTime decTickTime getTickTime isTicking " +
        "getUpdateCount getLiveness exit tryGetTextureSize " +
        "getTextureSize tryGetTextureSizeF getTextureSizeF reloadSymbols"

    let resolve relation world =
        let oldWorld = world
        try
            let relation =
                match ScriptingSystem.tryExport typeof<Relation<Object>> relation world with
                | Some value -> value :?> Relation<Object>
                | None -> failwith "Invalid argument type for 'relation'; expecting a value convertable to Relation`1."
            let result = World.resolveGeneric relation world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Address<Object>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'resolve' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadAssets world =
        let oldWorld = world
        try
            let result = World.reloadAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenIdling world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenIdling' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetIsSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.tryGetIsSelectedScreenTransitioning world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Boolean>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetIsSelectedScreenTransitioning' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenIdling world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenIdling world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenIdling' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSelectedScreenTransitioning world =
        let oldWorld = world
        try
            let result = World.isSelectedScreenTransitioning world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSelectedScreenTransitioning' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let selectScreen screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.selectScreen screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'selectScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryTransitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryTransitionScreen destination world
            let (value, world) = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryTransitionScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let transitionScreen destination world =
        let oldWorld = world
        try
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.transitionScreen destination world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'transitionScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromLayerFile6 dispatcherName nameOpt dissolveData layerFilePath world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveData =
                match ScriptingSystem.tryExport typeof<DissolveData> dissolveData world with
                | Some value -> value :?> DissolveData
                | None -> failwith "Invalid argument type for 'dissolveData'; expecting a value convertable to DissolveData."
            let layerFilePath =
                match ScriptingSystem.tryExport typeof<String> layerFilePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'layerFilePath'; expecting a value convertable to String."
            let result = World.createDissolveScreenFromLayerFile6 dispatcherName nameOpt dissolveData layerFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromLayerFile6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreenFromLayerFile nameOpt dissolveData layerFilePath world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveData =
                match ScriptingSystem.tryExport typeof<DissolveData> dissolveData world with
                | Some value -> value :?> DissolveData
                | None -> failwith "Invalid argument type for 'dissolveData'; expecting a value convertable to DissolveData."
            let layerFilePath =
                match ScriptingSystem.tryExport typeof<String> layerFilePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'layerFilePath'; expecting a value convertable to String."
            let result = World.createDissolveScreenFromLayerFile nameOpt dissolveData layerFilePath world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreenFromLayerFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createSplashScreen6 dispatcherName nameOpt splashData destination world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let splashData =
                match ScriptingSystem.tryExport typeof<SplashData> splashData world with
                | Some value -> value :?> SplashData
                | None -> failwith "Invalid argument type for 'splashData'; expecting a value convertable to SplashData."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSplashScreen6 dispatcherName nameOpt splashData destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSplashScreen6' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createSplashScreen nameOpt splashData destination world =
        let oldWorld = world
        try
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let splashData =
                match ScriptingSystem.tryExport typeof<SplashData> splashData world with
                | Some value -> value :?> SplashData
                | None -> failwith "Invalid argument type for 'splashData'; expecting a value convertable to SplashData."
            let struct (destination, world) =
                let context = World.getScriptContext world
                match World.evalInternal destination world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createSplashScreen nameOpt splashData destination world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createSplashScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesInView2 screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesInView2 screen world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesInView2' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesInBounds3 bounds screen world =
        let oldWorld = world
        try
            let bounds =
                match ScriptingSystem.tryExport typeof<Vector4> bounds world with
                | Some value -> value :?> Vector4
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Vector4."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesInBounds3 bounds screen world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesInBounds3' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesAtPoint3 point screen world =
        let oldWorld = world
        try
            let point =
                match ScriptingSystem.tryExport typeof<Vector2> point world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'point'; expecting a value convertable to Vector2."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntitiesAtPoint3 point screen world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesAtPoint3' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesInView world =
        let oldWorld = world
        try
            let result = World.getEntitiesInView world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesInView' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesInBounds bounds world =
        let oldWorld = world
        try
            let bounds =
                match ScriptingSystem.tryExport typeof<Vector4> bounds world with
                | Some value -> value :?> Vector4
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Vector4."
            let result = World.getEntitiesInBounds bounds world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesInBounds' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntitiesAtPoint point world =
        let oldWorld = world
        try
            let point =
                match ScriptingSystem.tryExport typeof<Vector2> point world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'point'; expecting a value convertable to Vector2."
            let result = World.getEntitiesAtPoint point world
            let (value, world) = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntitiesAtPoint' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSong timeToFadeOutSongMs volume song world =
        let oldWorld = world
        try
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let song =
                match ScriptingSystem.tryExport typeof<AssetTag<Audio>> song world with
                | Some value -> value :?> AssetTag<Audio>
                | None -> failwith "Invalid argument type for 'song'; expecting a value convertable to AssetTag`1."
            let result = World.playSong timeToFadeOutSongMs volume song world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSong4 timeToFadeOutSongMs volume songPackageName songAssetName world =
        let oldWorld = world
        try
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let songPackageName =
                match ScriptingSystem.tryExport typeof<String> songPackageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songPackageName'; expecting a value convertable to String."
            let songAssetName =
                match ScriptingSystem.tryExport typeof<String> songAssetName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'songAssetName'; expecting a value convertable to String."
            let result = World.playSong5 timeToFadeOutSongMs volume songPackageName songAssetName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSong4' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSound volume sound world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let sound =
                match ScriptingSystem.tryExport typeof<AssetTag<Audio>> sound world with
                | Some value -> value :?> AssetTag<Audio>
                | None -> failwith "Invalid argument type for 'sound'; expecting a value convertable to AssetTag`1."
            let result = World.playSound volume sound world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let playSound3 volume soundPackageName soundAssetName world =
        let oldWorld = world
        try
            let volume =
                match ScriptingSystem.tryExport typeof<Single> volume world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'volume'; expecting a value convertable to Single."
            let soundPackageName =
                match ScriptingSystem.tryExport typeof<String> soundPackageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'soundPackageName'; expecting a value convertable to String."
            let soundAssetName =
                match ScriptingSystem.tryExport typeof<String> soundAssetName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'soundAssetName'; expecting a value convertable to String."
            let result = World.playSound4 volume soundPackageName soundAssetName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'playSound3' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let fadeOutSong timeToFadeOutSongMs world =
        let oldWorld = world
        try
            let timeToFadeOutSongMs =
                match ScriptingSystem.tryExport typeof<Int32> timeToFadeOutSongMs world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'timeToFadeOutSongMs'; expecting a value convertable to Int32."
            let result = World.fadeOutSong timeToFadeOutSongMs world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'fadeOutSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let stopSong world =
        let oldWorld = world
        try
            let result = World.stopSong world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'stopSong' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintAudioPackageUse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintAudioPackageUse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintAudioPackageUse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintAudioPackageDisuse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintAudioPackageDisuse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintAudioPackageDisuse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadAudioAssets world =
        let oldWorld = world
        try
            let result = World.reloadAudioAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadAudioAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintRenderPackageUse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintRenderPackageUse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintRenderPackageUse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let hintRenderPackageDisuse packageName world =
        let oldWorld = world
        try
            let packageName =
                match ScriptingSystem.tryExport typeof<String> packageName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'packageName'; expecting a value convertable to String."
            let result = World.hintRenderPackageDisuse packageName world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'hintRenderPackageDisuse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadRenderAssets world =
        let oldWorld = world
        try
            let result = World.reloadRenderAssets world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadRenderAssets' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let bodyExists physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.bodyExists physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'bodyExists' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyContactNormals physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyContactNormals physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpList<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyContactNormals' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyLinearVelocity physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyLinearVelocity physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyLinearVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactNormals physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactNormals physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpList<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactNormals' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactNormalOpt physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactNormalOpt physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactNormalOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getBodyToGroundContactTangentOpt physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.getBodyToGroundContactTangentOpt physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getBodyToGroundContactTangentOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isBodyOnGround physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.isBodyOnGround physicsId world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBodyOnGround' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createBody entity entityId bodyProperties world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let entityId =
                match ScriptingSystem.tryExport typeof<Guid> entityId world with
                | Some value -> value :?> Guid
                | None -> failwith "Invalid argument type for 'entityId'; expecting a value convertable to Guid."
            let bodyProperties =
                match ScriptingSystem.tryExport typeof<BodyProperties> bodyProperties world with
                | Some value -> value :?> BodyProperties
                | None -> failwith "Invalid argument type for 'bodyProperties'; expecting a value convertable to BodyProperties."
            let result = World.createBody entity entityId bodyProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createBody' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createBodies entity entityId bodiesProperties world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let entityId =
                match ScriptingSystem.tryExport typeof<Guid> entityId world with
                | Some value -> value :?> Guid
                | None -> failwith "Invalid argument type for 'entityId'; expecting a value convertable to Guid."
            let struct (bodiesProperties, world) =
                match World.evalInternal bodiesProperties world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<BodyProperties> value world with
                            | Some value -> value :?> BodyProperties
                            | None -> failwith "Invalid argument type for 'bodiesProperties'; expecting a value convertable to BodyProperties."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createBodies entity entityId bodiesProperties world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createBodies' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyBody physicsId world =
        let oldWorld = world
        try
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.destroyBody physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyBody' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyBodies physicsIds world =
        let oldWorld = world
        try
            let struct (physicsIds, world) =
                match World.evalInternal physicsIds world with
                | struct (Scripting.List list, world) ->
                    Seq.fold (fun struct (values, world) value ->
                        let value =
                            match ScriptingSystem.tryExport typeof<PhysicsId> value world with
                            | Some value -> value :?> PhysicsId
                            | None -> failwith "Invalid argument type for 'physicsIds'; expecting a value convertable to PhysicsId."
                        struct (value :: values, world))
                        struct ([], world)
                        list
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyBodies physicsIds world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyBodies' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyPosition position physicsId world =
        let oldWorld = world
        try
            let position =
                match ScriptingSystem.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyPosition position physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyPosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyRotation rotation physicsId world =
        let oldWorld = world
        try
            let rotation =
                match ScriptingSystem.tryExport typeof<Single> rotation world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'rotation'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyRotation rotation physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyRotation' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyAngularVelocity angularVelocity physicsId world =
        let oldWorld = world
        try
            let angularVelocity =
                match ScriptingSystem.tryExport typeof<Single> angularVelocity world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'angularVelocity'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyAngularVelocity angularVelocity physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyAngularVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setBodyLinearVelocity linearVelocity physicsId world =
        let oldWorld = world
        try
            let linearVelocity =
                match ScriptingSystem.tryExport typeof<Vector2> linearVelocity world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'linearVelocity'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.setBodyLinearVelocity linearVelocity physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setBodyLinearVelocity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyAngularImpulse angularImpulse physicsId world =
        let oldWorld = world
        try
            let angularImpulse =
                match ScriptingSystem.tryExport typeof<Single> angularImpulse world with
                | Some value -> value :?> Single
                | None -> failwith "Invalid argument type for 'angularImpulse'; expecting a value convertable to Single."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyAngularImpulse angularImpulse physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyAngularImpulse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyLinearImpulse linearImpulse physicsId world =
        let oldWorld = world
        try
            let linearImpulse =
                match ScriptingSystem.tryExport typeof<Vector2> linearImpulse world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'linearImpulse'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyLinearImpulse linearImpulse physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyLinearImpulse' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let applyBodyForce force physicsId world =
        let oldWorld = world
        try
            let force =
                match ScriptingSystem.tryExport typeof<Vector2> force world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'force'; expecting a value convertable to Vector2."
            let physicsId =
                match ScriptingSystem.tryExport typeof<PhysicsId> physicsId world with
                | Some value -> value :?> PhysicsId
                | None -> failwith "Invalid argument type for 'physicsId'; expecting a value convertable to PhysicsId."
            let result = World.applyBodyForce force physicsId world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'applyBodyForce' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isMouseButtonDown mouseButton world =
        let oldWorld = world
        try
            let mouseButton =
                match ScriptingSystem.tryExport typeof<MouseButton> mouseButton world with
                | Some value -> value :?> MouseButton
                | None -> failwith "Invalid argument type for 'mouseButton'; expecting a value convertable to MouseButton."
            let result = World.isMouseButtonDown mouseButton world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isMouseButtonDown' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMousePosition world =
        let oldWorld = world
        try
            let result = World.getMousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2i> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePosition' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getMousePositionF world =
        let oldWorld = world
        try
            let result = World.getMousePositionF world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getMousePositionF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isKeyboardKeyDown scanCode world =
        let oldWorld = world
        try
            let scanCode =
                match ScriptingSystem.tryExport typeof<Int32> scanCode world with
                | Some value -> value :?> Int32
                | None -> failwith "Invalid argument type for 'scanCode'; expecting a value convertable to Int32."
            let result = World.isKeyboardKeyDown scanCode world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isKeyboardKeyDown' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSelected simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getSelected simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelected' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryGetParent simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetParent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getParent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getParent simulant world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getParent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetGrandparent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.tryGetGrandparent simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Simulant>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetGrandparent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getGrandparent simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getGrandparent simulant world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getGrandparent' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getChildren simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getChildren simulant world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getChildren' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getExists simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getExists simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getExists' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntities0 world =
        let oldWorld = world
        try
            let result = World.getEntities1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntities0' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getLayers0 world =
        let oldWorld = world
        try
            let result = World.getLayers1 world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLayers0' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isSimulantSelected simulant world =
        let oldWorld = world
        try
            let struct (simulant, world) =
                let context = World.getScriptContext world
                match World.evalInternal simulant world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (World.derive address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.isSimulantSelected simulant world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isSimulantSelected' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeGameToFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.writeGameToFile filePath world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeGameToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readGameFromFile filePath world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let result = World.readGameFromFile filePath world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readGameFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getScreens world =
        let oldWorld = world
        try
            let result = World.getScreens world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getScreens' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyScreen screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyScreen screen world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createScreen dispatcherName nameOpt world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.createScreen3 dispatcherName nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createDissolveScreen dispatcherName nameOpt dissolveData world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let dissolveData =
                match ScriptingSystem.tryExport typeof<DissolveData> dissolveData world with
                | Some value -> value :?> DissolveData
                | None -> failwith "Invalid argument type for 'dissolveData'; expecting a value convertable to DissolveData."
            let result = World.createDissolveScreen5 dispatcherName nameOpt dissolveData world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createDissolveScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeScreenToFile filePath screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeScreenToFile filePath screen world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeScreenToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readScreenFromFile filePath nameOpt world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let result = World.readScreenFromFile filePath nameOpt world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readScreenFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getLayers screen world =
        let oldWorld = world
        try
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getLayers screen world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLayers' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyLayer layer world =
        let oldWorld = world
        try
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyLayer layer world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyLayer' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyLayers layers world =
        let oldWorld = world
        try
            let struct (layers, world) =
                let context = World.getScriptContext world
                match World.evalInternal layers world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Layer address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyLayers layers world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyLayers' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let writeLayerToFile filePath layer world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.writeLayerToFile filePath layer world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Void> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'writeLayerToFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let readLayerFromFile filePath nameOpt screen world =
        let oldWorld = world
        try
            let filePath =
                match ScriptingSystem.tryExport typeof<String> filePath world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'filePath'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.readLayerFromFile filePath nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'readLayerFromFile' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEntities layer world =
        let oldWorld = world
        try
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.getEntities layer world
            let value = result
            let value = Scripting.Ring (Set.ofSeq (Seq.map (fun value -> let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str) value))
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEntities' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyEntity entity world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.destroyEntity entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let destroyEntities entities world =
        let oldWorld = world
        try
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.destroyEntities entities world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'destroyEntities' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryPickEntity position entities world =
        let oldWorld = world
        try
            let position =
                match ScriptingSystem.tryExport typeof<Vector2> position world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'position'; expecting a value convertable to Vector2."
            let struct (entities, world) =
                let context = World.getScriptContext world
                match World.evalInternal entities world with
                | struct (Scripting.List simulants, world) ->
                    List.fold (fun struct (simulants, world) simulant ->
                        match simulant with
                        | Scripting.String str
                        | Scripting.Keyword str ->
                            let relation = Relation.makeFromString str
                            let address = Relation.resolve context.SimulantAddress relation
                            struct (Entity address :: simulants, world)
                        | Scripting.Violation (_, error, _) -> failwith error
                        | _ -> failwith "Relation must be either a String or Keyword.")
                        struct ([], world)
                        simulants
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Expecting a list of relations."
            let result = World.tryPickEntity position entities world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Entity>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryPickEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createEntity dispatcherName nameOpt overlayNameDescriptor layer world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let overlayNameDescriptor =
                match ScriptingSystem.tryExport typeof<OverlayNameDescriptor> overlayNameDescriptor world with
                | Some value -> value :?> OverlayNameDescriptor
                | None -> failwith "Invalid argument type for 'overlayNameDescriptor'; expecting a value convertable to OverlayNameDescriptor."
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createEntity5 dispatcherName nameOpt overlayNameDescriptor layer world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reassignEntity entity nameOpt layer world =
        let oldWorld = world
        try
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (layer, world) =
                let context = World.getScriptContext world
                match World.evalInternal layer world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Layer address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.reassignEntity entity nameOpt layer world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reassignEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let trySetEntityOverlayNameOpt overlayNameOpt entity world =
        let oldWorld = world
        try
            let overlayNameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> overlayNameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'overlayNameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityOverlayNameOptFromScript overlayNameOpt entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityOverlayNameOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let trySetEntityFacetNames facetNames entity world =
        let oldWorld = world
        try
            let facetNames =
                match ScriptingSystem.tryExport typeof<FSharpSet<String>> facetNames world with
                | Some value -> value :?> FSharpSet<String>
                | None -> failwith "Invalid argument type for 'facetNames'; expecting a value convertable to FSharpSet`1."
            let struct (entity, world) =
                let context = World.getScriptContext world
                match World.evalInternal entity world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Entity address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.trySetEntityFacetNamesFromScript facetNames entity world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'trySetEntityFacetNames' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let createLayer dispatcherName nameOpt screen world =
        let oldWorld = world
        try
            let dispatcherName =
                match ScriptingSystem.tryExport typeof<String> dispatcherName world with
                | Some value -> value :?> String
                | None -> failwith "Invalid argument type for 'dispatcherName'; expecting a value convertable to String."
            let nameOpt =
                match ScriptingSystem.tryExport typeof<FSharpOption<String>> nameOpt world with
                | Some value -> value :?> FSharpOption<String>
                | None -> failwith "Invalid argument type for 'nameOpt'; expecting a value convertable to FSharpOption`1."
            let struct (screen, world) =
                let context = World.getScriptContext world
                match World.evalInternal screen world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.createLayer4 dispatcherName nameOpt screen world
            let (value, world) = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'createLayer' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyeCenter world =
        let oldWorld = world
        try
            let result = World.getEyeCenter world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeCenter' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setEyeCenter value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<Vector2> value world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector2."
            let result = World.setEyeCenter value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeCenter' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getEyeSize world =
        let oldWorld = world
        try
            let result = World.getEyeSize world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getEyeSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setEyeSize value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<Vector2> value world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to Vector2."
            let result = World.setEyeSize value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setEyeSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getOmniScreenOpt world =
        let oldWorld = world
        try
            let result = World.getOmniScreenOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOmniScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setOmniScreenOpt value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<FSharpOption<Screen>> value world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to FSharpOption`1."
            let result = World.setOmniScreenOpt value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setOmniScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getOmniScreen world =
        let oldWorld = world
        try
            let result = World.getOmniScreen world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getOmniScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setOmniScreen value world =
        let oldWorld = world
        try
            let struct (value, world) =
                let context = World.getScriptContext world
                match World.evalInternal value world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setOmniScreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setOmniScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSelectedScreenOpt world =
        let oldWorld = world
        try
            let result = World.getSelectedScreenOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelectedScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setSelectedScreenOpt value world =
        let oldWorld = world
        try
            let value =
                match ScriptingSystem.tryExport typeof<FSharpOption<Screen>> value world with
                | Some value -> value :?> FSharpOption<Screen>
                | None -> failwith "Invalid argument type for 'value'; expecting a value convertable to FSharpOption`1."
            let result = World.setSelectedScreenOpt value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setSelectedScreenOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getSelectedScreen world =
        let oldWorld = world
        try
            let result = World.getSelectedScreen world
            let value = result
            let value = let str = scstring value in if Symbol.shouldBeExplicit str then Scripting.String str else Scripting.Keyword str
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getSelectedScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setSelectedScreen value world =
        let oldWorld = world
        try
            let struct (value, world) =
                let context = World.getScriptContext world
                match World.evalInternal value world with
                | struct (Scripting.String str, world)
                | struct (Scripting.Keyword str, world) ->
                    let relation = Relation.makeFromString str
                    let address = Relation.resolve context.SimulantAddress relation
                    struct (Screen address, world)
                | struct (Scripting.Violation (_, error, _), _) -> failwith error
                | struct (_, _) -> failwith "Relation must be either a String or Keyword."
            let result = World.setSelectedScreen value world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setSelectedScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getScreenTransitionDestinationOpt world =
        let oldWorld = world
        try
            let result = World.getScreenTransitionDestinationOpt world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Screen>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getScreenTransitionDestinationOpt' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBoundsRelative world =
        let oldWorld = world
        try
            let result = World.getViewBoundsRelative world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBoundsRelative' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBoundsAbsolute world =
        let oldWorld = world
        try
            let result = World.getViewBoundsAbsolute world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBoundsAbsolute' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getViewBounds viewType world =
        let oldWorld = world
        try
            let viewType =
                match ScriptingSystem.tryExport typeof<ViewType> viewType world with
                | Some value -> value :?> ViewType
                | None -> failwith "Invalid argument type for 'viewType'; expecting a value convertable to ViewType."
            let result = World.getViewBounds viewType world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector4> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getViewBounds' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isBoundsInView viewType bounds world =
        let oldWorld = world
        try
            let viewType =
                match ScriptingSystem.tryExport typeof<ViewType> viewType world with
                | Some value -> value :?> ViewType
                | None -> failwith "Invalid argument type for 'viewType'; expecting a value convertable to ViewType."
            let bounds =
                match ScriptingSystem.tryExport typeof<Vector4> bounds world with
                | Some value -> value :?> Vector4
                | None -> failwith "Invalid argument type for 'bounds'; expecting a value convertable to Vector4."
            let result = World.isBoundsInView viewType bounds world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isBoundsInView' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToScreen mousePosition world =
        let oldWorld = world
        try
            let mousePosition =
                match ScriptingSystem.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToScreen mousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToScreen' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToWorld viewType mousePosition world =
        let oldWorld = world
        try
            let viewType =
                match ScriptingSystem.tryExport typeof<ViewType> viewType world with
                | Some value -> value :?> ViewType
                | None -> failwith "Invalid argument type for 'viewType'; expecting a value convertable to ViewType."
            let mousePosition =
                match ScriptingSystem.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToWorld viewType mousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToWorld' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let mouseToEntity viewType entityPosition mousePosition world =
        let oldWorld = world
        try
            let viewType =
                match ScriptingSystem.tryExport typeof<ViewType> viewType world with
                | Some value -> value :?> ViewType
                | None -> failwith "Invalid argument type for 'viewType'; expecting a value convertable to ViewType."
            let entityPosition =
                match ScriptingSystem.tryExport typeof<Vector2> entityPosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'entityPosition'; expecting a value convertable to Vector2."
            let mousePosition =
                match ScriptingSystem.tryExport typeof<Vector2> mousePosition world with
                | Some value -> value :?> Vector2
                | None -> failwith "Invalid argument type for 'mousePosition'; expecting a value convertable to Vector2."
            let result = World.mouseToEntity viewType entityPosition mousePosition world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'mouseToEntity' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickRate world =
        let oldWorld = world
        try
            let result = World.getTickRate world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickRate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickRateF world =
        let oldWorld = world
        try
            let result = World.getTickRateF world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Single> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickRateF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let setTickRate tickRate world =
        let oldWorld = world
        try
            let tickRate =
                match ScriptingSystem.tryExport typeof<Int64> tickRate world with
                | Some value -> value :?> Int64
                | None -> failwith "Invalid argument type for 'tickRate'; expecting a value convertable to Int64."
            let result = World.setTickRate tickRate world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'setTickRate' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let resetTickTime world =
        let oldWorld = world
        try
            let result = World.resetTickTime world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'resetTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let incTickTime world =
        let oldWorld = world
        try
            let result = World.incTickTime world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'incTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let decTickTime world =
        let oldWorld = world
        try
            let result = World.decTickTime world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'decTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTickTime world =
        let oldWorld = world
        try
            let result = World.getTickTime world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTickTime' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let isTicking world =
        let oldWorld = world
        try
            let result = World.isTicking world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Boolean> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'isTicking' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getUpdateCount world =
        let oldWorld = world
        try
            let result = World.getUpdateCount world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Int64> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getUpdateCount' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getLiveness world =
        let oldWorld = world
        try
            let result = World.getLiveness world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Liveness> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getLiveness' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let exit world =
        let oldWorld = world
        try
            let result = World.exit world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'exit' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSize assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2i>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTextureSize assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSize assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2i> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSize' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let tryGetTextureSizeF assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.tryGetTextureSizeF assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<FSharpOption<Vector2>> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'tryGetTextureSizeF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let getTextureSizeF assetTag world =
        let oldWorld = world
        try
            let assetTag =
                match ScriptingSystem.tryExport typeof<AssetTag<Image>> assetTag world with
                | Some value -> value :?> AssetTag<Image>
                | None -> failwith "Invalid argument type for 'assetTag'; expecting a value convertable to AssetTag`1."
            let result = World.getTextureSizeF assetTag world
            let value = result
            let value = ScriptingSystem.tryImport typeof<Vector2> value world |> Option.get
            struct (value, world)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'getTextureSizeF' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let reloadSymbols world =
        let oldWorld = world
        try
            let result = World.reloadSymbols world
            struct (Scripting.Unit, result)
        with exn ->
            let violation = Scripting.Violation (["InvalidBindingInvocation"], "Could not invoke binding 'reloadSymbols' due to: " + scstring exn, None)
            struct (violation, World.choose oldWorld)

    let evalResolveBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|relation|] -> resolve relation world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadAssets  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetIsSelectedScreenIdling  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> tryGetIsSelectedScreenTransitioning  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedScreenIdlingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isSelectedScreenIdling  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSelectedScreenTransitioningBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isSelectedScreenTransitioning  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSelectScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> selectScreen screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryTransitionScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|destination|] -> tryTransitionScreen destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTransitionScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|destination|] -> transitionScreen destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenFromLayerFile6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; dissolveData; layerFilePath|] -> createDissolveScreenFromLayerFile6 dispatcherName nameOpt dissolveData layerFilePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenFromLayerFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nameOpt; dissolveData; layerFilePath|] -> createDissolveScreenFromLayerFile nameOpt dissolveData layerFilePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateSplashScreen6Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; splashData; destination|] -> createSplashScreen6 dispatcherName nameOpt splashData destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateSplashScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|nameOpt; splashData; destination|] -> createSplashScreen nameOpt splashData destination world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesInView2Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> getEntitiesInView2 screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesInBounds3Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bounds; screen|] -> getEntitiesInBounds3 bounds screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesAtPoint3Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|point; screen|] -> getEntitiesAtPoint3 point screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesInViewBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEntitiesInView  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesInBoundsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|bounds|] -> getEntitiesInBounds bounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesAtPointBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|point|] -> getEntitiesAtPoint point world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeOutSongMs; volume; song|] -> playSong timeToFadeOutSongMs volume song world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySong4Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeOutSongMs; volume; songPackageName; songAssetName|] -> playSong4 timeToFadeOutSongMs volume songPackageName songAssetName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySoundBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume; sound|] -> playSound volume sound world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalPlaySound3Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|volume; soundPackageName; soundAssetName|] -> playSound3 volume soundPackageName soundAssetName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalFadeOutSongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|timeToFadeOutSongMs|] -> fadeOutSong timeToFadeOutSongMs world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalStopSongBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> stopSong  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintAudioPackageUseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintAudioPackageUse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintAudioPackageDisuseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintAudioPackageDisuse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadAudioAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadAudioAssets  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintRenderPackageUseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintRenderPackageUse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalHintRenderPackageDisuseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|packageName|] -> hintRenderPackageDisuse packageName world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadRenderAssetsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadRenderAssets  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalBodyExistsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> bodyExists physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyContactNormalsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyContactNormals physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyLinearVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyLinearVelocity physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactNormalsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyToGroundContactNormals physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactNormalOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyToGroundContactNormalOpt physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetBodyToGroundContactTangentOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> getBodyToGroundContactTangentOpt physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsBodyOnGroundBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> isBodyOnGround physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateBodyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity; entityId; bodyProperties|] -> createBody entity entityId bodyProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateBodiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity; entityId; bodiesProperties|] -> createBodies entity entityId bodiesProperties world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBodyBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsId|] -> destroyBody physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyBodiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|physicsIds|] -> destroyBodies physicsIds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyPositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|position; physicsId|] -> setBodyPosition position physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyRotationBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|rotation; physicsId|] -> setBodyRotation rotation physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyAngularVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|angularVelocity; physicsId|] -> setBodyAngularVelocity angularVelocity physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetBodyLinearVelocityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|linearVelocity; physicsId|] -> setBodyLinearVelocity linearVelocity physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyAngularImpulseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|angularImpulse; physicsId|] -> applyBodyAngularImpulse angularImpulse physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyLinearImpulseBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|linearImpulse; physicsId|] -> applyBodyLinearImpulse linearImpulse physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalApplyBodyForceBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|force; physicsId|] -> applyBodyForce force physicsId world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsMouseButtonDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|mouseButton|] -> isMouseButtonDown mouseButton world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMousePositionBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMousePosition  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetMousePositionFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getMousePositionF  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsKeyboardKeyDownBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|scanCode|] -> isKeyboardKeyDown scanCode world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetSelectedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getSelected simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetParentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> tryGetParent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetParentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getParent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetGrandparentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> tryGetGrandparent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetGrandparentBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getGrandparent simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetChildrenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getChildren simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetExistsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> getExists simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntities0Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEntities0  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetLayers0Binding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getLayers0  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsSimulantSelectedBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|simulant|] -> isSimulantSelected simulant world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteGameToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath|] -> writeGameToFile filePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadGameFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath|] -> readGameFromFile filePath world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetScreensBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getScreens  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> destroyScreen screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt|] -> createScreen dispatcherName nameOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateDissolveScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; dissolveData|] -> createDissolveScreen dispatcherName nameOpt dissolveData world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteScreenToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; screen|] -> writeScreenToFile filePath screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadScreenFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt|] -> readScreenFromFile filePath nameOpt world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetLayersBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|screen|] -> getLayers screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyLayerBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|layer|] -> destroyLayer layer world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyLayersBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|layers|] -> destroyLayers layers world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalWriteLayerToFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; layer|] -> writeLayerToFile filePath layer world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReadLayerFromFileBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|filePath; nameOpt; screen|] -> readLayerFromFile filePath nameOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEntitiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|layer|] -> getEntities layer world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity|] -> destroyEntity entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDestroyEntitiesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entities|] -> destroyEntities entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryPickEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|position; entities|] -> tryPickEntity position entities world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; overlayNameDescriptor; layer|] -> createEntity dispatcherName nameOpt overlayNameDescriptor layer world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReassignEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|entity; nameOpt; layer|] -> reassignEntity entity nameOpt layer world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEntityOverlayNameOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|overlayNameOpt; entity|] -> trySetEntityOverlayNameOpt overlayNameOpt entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTrySetEntityFacetNamesBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|facetNames; entity|] -> trySetEntityFacetNames facetNames entity world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalCreateLayerBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|dispatcherName; nameOpt; screen|] -> createLayer dispatcherName nameOpt screen world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeCenterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeCenter  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEyeCenterBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setEyeCenter value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetEyeSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getEyeSize  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetEyeSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setEyeSize value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetOmniScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getOmniScreenOpt  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetOmniScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setOmniScreenOpt value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetOmniScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getOmniScreen  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetOmniScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setOmniScreen value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetSelectedScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getSelectedScreenOpt  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetSelectedScreenOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setSelectedScreenOpt value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetSelectedScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getSelectedScreen  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetSelectedScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|value|] -> setSelectedScreen value world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetScreenTransitionDestinationOptBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getScreenTransitionDestinationOpt  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewBoundsRelativeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getViewBoundsRelative  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewBoundsAbsoluteBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getViewBoundsAbsolute  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetViewBoundsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|viewType|] -> getViewBounds viewType world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsBoundsInViewBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|viewType; bounds|] -> isBoundsInView viewType bounds world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalMouseToScreenBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|mousePosition|] -> mouseToScreen mousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalMouseToWorldBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|viewType; mousePosition|] -> mouseToWorld viewType mousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalMouseToEntityBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|viewType; entityPosition; mousePosition|] -> mouseToEntity viewType entityPosition mousePosition world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTickRateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getTickRate  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTickRateFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getTickRateF  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalSetTickRateBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|tickRate|] -> setTickRate tickRate world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalResetTickTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> resetTickTime  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIncTickTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> incTickTime  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalDecTickTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> decTickTime  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTickTimeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getTickTime  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalIsTickingBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> isTicking  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetUpdateCountBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getUpdateCount  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetLivenessBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> getLiveness  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalExitBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> exit  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetTextureSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> tryGetTextureSize assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTextureSizeBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> getTextureSize assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalTryGetTextureSizeFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> tryGetTextureSizeF assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalGetTextureSizeFBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [|assetTag|] -> getTextureSizeF assetTag world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let evalReloadSymbolsBinding fnName exprs originOpt world =
        let struct (evaleds, world) = World.evalManyInternal exprs world
        match Array.tryFind (function Scripting.Violation _ -> true | _ -> false) evaleds with
        | None ->
            match evaleds with
            | [||] -> reloadSymbols  world
            | _ ->
                let violation = Scripting.Violation (["InvalidBindingInvocation"], "Incorrect number of arguments for binding '" + fnName + "' at:\n" + SymbolOrigin.tryPrint originOpt, None)
                struct (violation, world)
        | Some violation -> struct (violation, world)

    let tryGetBinding fnName =
        match WorldScripting.Bindings.TryGetValue fnName with
        | (true, binding) -> FOption.some binding
        | (false, _) -> FOption.none ()

    let initBindings () =
        let bindings =
            [
             ("resolve", { Fn = evalResolveBinding; Pars = [|"relation"|]; DocOpt = None })
             ("reloadAssets", { Fn = evalReloadAssetsBinding; Pars = [||]; DocOpt = None })
             ("tryGetIsSelectedScreenIdling", { Fn = evalTryGetIsSelectedScreenIdlingBinding; Pars = [||]; DocOpt = None })
             ("tryGetIsSelectedScreenTransitioning", { Fn = evalTryGetIsSelectedScreenTransitioningBinding; Pars = [||]; DocOpt = None })
             ("isSelectedScreenIdling", { Fn = evalIsSelectedScreenIdlingBinding; Pars = [||]; DocOpt = None })
             ("isSelectedScreenTransitioning", { Fn = evalIsSelectedScreenTransitioningBinding; Pars = [||]; DocOpt = None })
             ("selectScreen", { Fn = evalSelectScreenBinding; Pars = [|"screen"|]; DocOpt = None })
             ("tryTransitionScreen", { Fn = evalTryTransitionScreenBinding; Pars = [|"destination"|]; DocOpt = None })
             ("transitionScreen", { Fn = evalTransitionScreenBinding; Pars = [|"destination"|]; DocOpt = None })
             ("createDissolveScreenFromLayerFile6", { Fn = evalCreateDissolveScreenFromLayerFile6Binding; Pars = [|"dispatcherName"; "nameOpt"; "dissolveData"; "layerFilePath"|]; DocOpt = None })
             ("createDissolveScreenFromLayerFile", { Fn = evalCreateDissolveScreenFromLayerFileBinding; Pars = [|"nameOpt"; "dissolveData"; "layerFilePath"|]; DocOpt = None })
             ("createSplashScreen6", { Fn = evalCreateSplashScreen6Binding; Pars = [|"dispatcherName"; "nameOpt"; "splashData"; "destination"|]; DocOpt = None })
             ("createSplashScreen", { Fn = evalCreateSplashScreenBinding; Pars = [|"nameOpt"; "splashData"; "destination"|]; DocOpt = None })
             ("getEntitiesInView2", { Fn = evalGetEntitiesInView2Binding; Pars = [|"screen"|]; DocOpt = None })
             ("getEntitiesInBounds3", { Fn = evalGetEntitiesInBounds3Binding; Pars = [|"bounds"; "screen"|]; DocOpt = None })
             ("getEntitiesAtPoint3", { Fn = evalGetEntitiesAtPoint3Binding; Pars = [|"point"; "screen"|]; DocOpt = None })
             ("getEntitiesInView", { Fn = evalGetEntitiesInViewBinding; Pars = [||]; DocOpt = None })
             ("getEntitiesInBounds", { Fn = evalGetEntitiesInBoundsBinding; Pars = [|"bounds"|]; DocOpt = None })
             ("getEntitiesAtPoint", { Fn = evalGetEntitiesAtPointBinding; Pars = [|"point"|]; DocOpt = None })
             ("playSong", { Fn = evalPlaySongBinding; Pars = [|"timeToFadeOutSongMs"; "volume"; "song"|]; DocOpt = None })
             ("playSong4", { Fn = evalPlaySong4Binding; Pars = [|"timeToFadeOutSongMs"; "volume"; "songPackageName"; "songAssetName"|]; DocOpt = None })
             ("playSound", { Fn = evalPlaySoundBinding; Pars = [|"volume"; "sound"|]; DocOpt = None })
             ("playSound3", { Fn = evalPlaySound3Binding; Pars = [|"volume"; "soundPackageName"; "soundAssetName"|]; DocOpt = None })
             ("fadeOutSong", { Fn = evalFadeOutSongBinding; Pars = [|"timeToFadeOutSongMs"|]; DocOpt = None })
             ("stopSong", { Fn = evalStopSongBinding; Pars = [||]; DocOpt = None })
             ("hintAudioPackageUse", { Fn = evalHintAudioPackageUseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("hintAudioPackageDisuse", { Fn = evalHintAudioPackageDisuseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("reloadAudioAssets", { Fn = evalReloadAudioAssetsBinding; Pars = [||]; DocOpt = None })
             ("hintRenderPackageUse", { Fn = evalHintRenderPackageUseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("hintRenderPackageDisuse", { Fn = evalHintRenderPackageDisuseBinding; Pars = [|"packageName"|]; DocOpt = None })
             ("reloadRenderAssets", { Fn = evalReloadRenderAssetsBinding; Pars = [||]; DocOpt = None })
             ("bodyExists", { Fn = evalBodyExistsBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyContactNormals", { Fn = evalGetBodyContactNormalsBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyLinearVelocity", { Fn = evalGetBodyLinearVelocityBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyToGroundContactNormals", { Fn = evalGetBodyToGroundContactNormalsBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyToGroundContactNormalOpt", { Fn = evalGetBodyToGroundContactNormalOptBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("getBodyToGroundContactTangentOpt", { Fn = evalGetBodyToGroundContactTangentOptBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("isBodyOnGround", { Fn = evalIsBodyOnGroundBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("createBody", { Fn = evalCreateBodyBinding; Pars = [|"entity"; "entityId"; "bodyProperties"|]; DocOpt = None })
             ("createBodies", { Fn = evalCreateBodiesBinding; Pars = [|"entity"; "entityId"; "bodiesProperties"|]; DocOpt = None })
             ("destroyBody", { Fn = evalDestroyBodyBinding; Pars = [|"physicsId"|]; DocOpt = None })
             ("destroyBodies", { Fn = evalDestroyBodiesBinding; Pars = [|"physicsIds"|]; DocOpt = None })
             ("setBodyPosition", { Fn = evalSetBodyPositionBinding; Pars = [|"position"; "physicsId"|]; DocOpt = None })
             ("setBodyRotation", { Fn = evalSetBodyRotationBinding; Pars = [|"rotation"; "physicsId"|]; DocOpt = None })
             ("setBodyAngularVelocity", { Fn = evalSetBodyAngularVelocityBinding; Pars = [|"angularVelocity"; "physicsId"|]; DocOpt = None })
             ("setBodyLinearVelocity", { Fn = evalSetBodyLinearVelocityBinding; Pars = [|"linearVelocity"; "physicsId"|]; DocOpt = None })
             ("applyBodyAngularImpulse", { Fn = evalApplyBodyAngularImpulseBinding; Pars = [|"angularImpulse"; "physicsId"|]; DocOpt = None })
             ("applyBodyLinearImpulse", { Fn = evalApplyBodyLinearImpulseBinding; Pars = [|"linearImpulse"; "physicsId"|]; DocOpt = None })
             ("applyBodyForce", { Fn = evalApplyBodyForceBinding; Pars = [|"force"; "physicsId"|]; DocOpt = None })
             ("isMouseButtonDown", { Fn = evalIsMouseButtonDownBinding; Pars = [|"mouseButton"|]; DocOpt = None })
             ("getMousePosition", { Fn = evalGetMousePositionBinding; Pars = [||]; DocOpt = None })
             ("getMousePositionF", { Fn = evalGetMousePositionFBinding; Pars = [||]; DocOpt = None })
             ("isKeyboardKeyDown", { Fn = evalIsKeyboardKeyDownBinding; Pars = [|"scanCode"|]; DocOpt = None })
             ("getSelected", { Fn = evalGetSelectedBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("tryGetParent", { Fn = evalTryGetParentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getParent", { Fn = evalGetParentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("tryGetGrandparent", { Fn = evalTryGetGrandparentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getGrandparent", { Fn = evalGetGrandparentBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getChildren", { Fn = evalGetChildrenBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getExists", { Fn = evalGetExistsBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("getEntities0", { Fn = evalGetEntities0Binding; Pars = [||]; DocOpt = None })
             ("getLayers0", { Fn = evalGetLayers0Binding; Pars = [||]; DocOpt = None })
             ("isSimulantSelected", { Fn = evalIsSimulantSelectedBinding; Pars = [|"simulant"|]; DocOpt = None })
             ("writeGameToFile", { Fn = evalWriteGameToFileBinding; Pars = [|"filePath"|]; DocOpt = None })
             ("readGameFromFile", { Fn = evalReadGameFromFileBinding; Pars = [|"filePath"|]; DocOpt = None })
             ("getScreens", { Fn = evalGetScreensBinding; Pars = [||]; DocOpt = None })
             ("destroyScreen", { Fn = evalDestroyScreenBinding; Pars = [|"screen"|]; DocOpt = None })
             ("createScreen", { Fn = evalCreateScreenBinding; Pars = [|"dispatcherName"; "nameOpt"|]; DocOpt = None })
             ("createDissolveScreen", { Fn = evalCreateDissolveScreenBinding; Pars = [|"dispatcherName"; "nameOpt"; "dissolveData"|]; DocOpt = None })
             ("writeScreenToFile", { Fn = evalWriteScreenToFileBinding; Pars = [|"filePath"; "screen"|]; DocOpt = None })
             ("readScreenFromFile", { Fn = evalReadScreenFromFileBinding; Pars = [|"filePath"; "nameOpt"|]; DocOpt = None })
             ("getLayers", { Fn = evalGetLayersBinding; Pars = [|"screen"|]; DocOpt = None })
             ("destroyLayer", { Fn = evalDestroyLayerBinding; Pars = [|"layer"|]; DocOpt = None })
             ("destroyLayers", { Fn = evalDestroyLayersBinding; Pars = [|"layers"|]; DocOpt = None })
             ("writeLayerToFile", { Fn = evalWriteLayerToFileBinding; Pars = [|"filePath"; "layer"|]; DocOpt = None })
             ("readLayerFromFile", { Fn = evalReadLayerFromFileBinding; Pars = [|"filePath"; "nameOpt"; "screen"|]; DocOpt = None })
             ("getEntities", { Fn = evalGetEntitiesBinding; Pars = [|"layer"|]; DocOpt = None })
             ("destroyEntity", { Fn = evalDestroyEntityBinding; Pars = [|"entity"|]; DocOpt = None })
             ("destroyEntities", { Fn = evalDestroyEntitiesBinding; Pars = [|"entities"|]; DocOpt = None })
             ("tryPickEntity", { Fn = evalTryPickEntityBinding; Pars = [|"position"; "entities"|]; DocOpt = None })
             ("createEntity", { Fn = evalCreateEntityBinding; Pars = [|"dispatcherName"; "nameOpt"; "overlayNameDescriptor"; "layer"|]; DocOpt = None })
             ("reassignEntity", { Fn = evalReassignEntityBinding; Pars = [|"entity"; "nameOpt"; "layer"|]; DocOpt = None })
             ("trySetEntityOverlayNameOpt", { Fn = evalTrySetEntityOverlayNameOptBinding; Pars = [|"overlayNameOpt"; "entity"|]; DocOpt = None })
             ("trySetEntityFacetNames", { Fn = evalTrySetEntityFacetNamesBinding; Pars = [|"facetNames"; "entity"|]; DocOpt = None })
             ("createLayer", { Fn = evalCreateLayerBinding; Pars = [|"dispatcherName"; "nameOpt"; "screen"|]; DocOpt = None })
             ("getEyeCenter", { Fn = evalGetEyeCenterBinding; Pars = [||]; DocOpt = None })
             ("setEyeCenter", { Fn = evalSetEyeCenterBinding; Pars = [|"value"|]; DocOpt = None })
             ("getEyeSize", { Fn = evalGetEyeSizeBinding; Pars = [||]; DocOpt = None })
             ("setEyeSize", { Fn = evalSetEyeSizeBinding; Pars = [|"value"|]; DocOpt = None })
             ("getOmniScreenOpt", { Fn = evalGetOmniScreenOptBinding; Pars = [||]; DocOpt = None })
             ("setOmniScreenOpt", { Fn = evalSetOmniScreenOptBinding; Pars = [|"value"|]; DocOpt = None })
             ("getOmniScreen", { Fn = evalGetOmniScreenBinding; Pars = [||]; DocOpt = None })
             ("setOmniScreen", { Fn = evalSetOmniScreenBinding; Pars = [|"value"|]; DocOpt = None })
             ("getSelectedScreenOpt", { Fn = evalGetSelectedScreenOptBinding; Pars = [||]; DocOpt = None })
             ("setSelectedScreenOpt", { Fn = evalSetSelectedScreenOptBinding; Pars = [|"value"|]; DocOpt = None })
             ("getSelectedScreen", { Fn = evalGetSelectedScreenBinding; Pars = [||]; DocOpt = None })
             ("setSelectedScreen", { Fn = evalSetSelectedScreenBinding; Pars = [|"value"|]; DocOpt = None })
             ("getScreenTransitionDestinationOpt", { Fn = evalGetScreenTransitionDestinationOptBinding; Pars = [||]; DocOpt = None })
             ("getViewBoundsRelative", { Fn = evalGetViewBoundsRelativeBinding; Pars = [||]; DocOpt = None })
             ("getViewBoundsAbsolute", { Fn = evalGetViewBoundsAbsoluteBinding; Pars = [||]; DocOpt = None })
             ("getViewBounds", { Fn = evalGetViewBoundsBinding; Pars = [|"viewType"|]; DocOpt = None })
             ("isBoundsInView", { Fn = evalIsBoundsInViewBinding; Pars = [|"viewType"; "bounds"|]; DocOpt = None })
             ("mouseToScreen", { Fn = evalMouseToScreenBinding; Pars = [|"mousePosition"|]; DocOpt = None })
             ("mouseToWorld", { Fn = evalMouseToWorldBinding; Pars = [|"viewType"; "mousePosition"|]; DocOpt = None })
             ("mouseToEntity", { Fn = evalMouseToEntityBinding; Pars = [|"viewType"; "entityPosition"; "mousePosition"|]; DocOpt = None })
             ("getTickRate", { Fn = evalGetTickRateBinding; Pars = [||]; DocOpt = None })
             ("getTickRateF", { Fn = evalGetTickRateFBinding; Pars = [||]; DocOpt = None })
             ("setTickRate", { Fn = evalSetTickRateBinding; Pars = [|"tickRate"|]; DocOpt = None })
             ("resetTickTime", { Fn = evalResetTickTimeBinding; Pars = [||]; DocOpt = None })
             ("incTickTime", { Fn = evalIncTickTimeBinding; Pars = [||]; DocOpt = None })
             ("decTickTime", { Fn = evalDecTickTimeBinding; Pars = [||]; DocOpt = None })
             ("getTickTime", { Fn = evalGetTickTimeBinding; Pars = [||]; DocOpt = None })
             ("isTicking", { Fn = evalIsTickingBinding; Pars = [||]; DocOpt = None })
             ("getUpdateCount", { Fn = evalGetUpdateCountBinding; Pars = [||]; DocOpt = None })
             ("getLiveness", { Fn = evalGetLivenessBinding; Pars = [||]; DocOpt = None })
             ("exit", { Fn = evalExitBinding; Pars = [||]; DocOpt = None })
             ("tryGetTextureSize", { Fn = evalTryGetTextureSizeBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getTextureSize", { Fn = evalGetTextureSizeBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("tryGetTextureSizeF", { Fn = evalTryGetTextureSizeFBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("getTextureSizeF", { Fn = evalGetTextureSizeFBinding; Pars = [|"assetTag"|]; DocOpt = None })
             ("reloadSymbols", { Fn = evalReloadSymbolsBinding; Pars = [||]; DocOpt = None })
            ] |>
            dictPlus
        WorldScripting.Bindings <- bindings
